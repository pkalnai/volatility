# Detecting browser hooks for Volatility Framework
#
# LICENSE
# Please refer to the LICENSE.txt in the https://github.com/JPCERTCC/aa-tools/
#
# How to use:
# 1. cd "Volatility Folder"
# 2. mv browser_hooks.py volatility/plugins/malware
# 3. python vol.py browser_hooks -f images.mem --profile=Win7SP1x64

import volatility.plugins.taskmods as taskmods
import volatility.win32.tasks as tasks
import volatility.utils as utils
import volatility.debug as debug
import volatility.plugins.malware.malfind as malfind
import volatility.plugins.malware as malware
from volatility.plugins.taskmods import DllList, PSList
import re
from struct import pack, unpack, unpack_from, calcsize

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False

               
GOOGLE_CHROME_X86_PATTERN = {
    'namespace1' : 'rule GoogleChromex86 { \
                    strings: \
                       $pattern = { 85 C0 0F 44 CA 89 0E B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? } \
                    condition: $pattern  }'
}

GOOGLE_CHROME_X86_FILTER = [['dlllist', 'chrome.dll']
]

class patternCheck():
    def __init__(self, malname, data):
        for c_name, c_pt in CONF_PATTERNS:
            if c_name in str(malname):
                self.m_conf = re.search(c_pt, data)
                break
            else:
                self.m_conf = None

        for s_name, s_pt in SIZE_PATTERNS:
            if s_name in str(malname):
                self.m_size = re.search(s_pt, data)
                break
            else:
                self.m_size = None


class browser_hooks_chrome_x86(malfind.YaraScan):
    "Find browser hooks for Google Chrome x86"

    @staticmethod
    def is_valid_profile(profile):
        return ( profile.metadata.get('os', 'Unknown').lower() == 'windows', profile.metadata.get('memory_model', '32bit'))

    def get_vad_base(self, task, address):
        """ Get the VAD starting address """        

        for vad in task.VadRoot.traverse():
            if address >= vad.Start and address < vad.End:
                return vad.Start

        # This should never really happen
        return None

    def filter_tasks(self):
        procs = PSList(self._config).calculate()

        tasks_filt = []
        for task in procs:
            pid = task.UniqueProcessId
            for c_plug, c_filter in GOOGLE_CHROME_X86_FILTER: 
                if c_plug == 'dlllist':
                   if task.Peb:
                      for m in task.get_load_modules():
                          dllname= str(m.FullDllName)
                          if c_filter in dllname:
                              size = m.SizeOfImage
                              base = m.DllBase
                              tasks_filt.append(task)
                              print("Suspected PID: {0:8} contains {1:8s} of size {2:8} based {3:#x}\n".format(pid, dllname, size,base))                         

        return tasks_filt
   
    def calculate(self):
    
        ## we need this module imported
        if not has_yara:
            debug.error("Please install Yara from https://plusvic.github.io/yara/")

        addr_space = utils.load_as(self._config)

        os, memory_model = self.is_valid_profile(addr_space.profile)
        if not os:
            debug.error("This command does not support the selected profile.")
            
        ## leveraged from the windows yarascan plugin
        rules = yara.compile(sources = GOOGLE_CHROME_X86_PATTERN)
            
        tasks = self.filter_tasks()
        for task in tasks: 
            scanner = malfind.VadYaraScanner(task = task, rules = rules)
            for vad, address_space in task.get_vads():
               for hit, address in scanner.scan():

                    vad_base_addr = self.get_vad_base(task, address)
                    # Get a chuck of memory of size 2048 next to where the string was detected
                    content = address_space.zread(address, 2048)

                    yield task, address, vad_base_addr, content
                    #yield (task, address, hit, scanner.address_space.zread(address - self._config.REVERSE, self._config.SIZE))
                    break

    def render_text(self, outfd, data):

        for task, address, hit, buf in data:
            outfd.write("".join(["{0:#010x}  {1:<48}  {2}\n".format( address + o, h, ''.join(c)) for o, h, c in utils.Hexdump(buf)]))
            break
