# Author: ESET Research/Peter Kalnai (peter.kalnai@eset.cz)
# 16th November 2016
#
# Detecting Linux/Rakos.A malware as a plugin for Volatility Framework
#
# Usage:
# 1) cd "Volatility Folder"
# 2) mv vf_ioc_linux_rakos.py volatility/plugins/malware
# 3) python vol.py -f dump_from_compromise_linux_system.vmem --profile=LinuxUbuntu_14_04_krn_4_2_AMDx64 vf_ioc_linux_rakos

# version 1.0


import volatility.utils as utils
import volatility.debug as debug
import volatility.plugins.malware.malfind as malfind
import volatility.plugins.malware as malware
import volatility.plugins.linux.common as linux_common
import volatility.plugins.linux.banner as linux_banner
import volatility.plugins.linux.cpuinfo as linux_cpuinfo
import volatility.plugins.linux.pslist as pslist
import volatility.plugins.linux.linux_yarascan as linux_yarascan
import re, socket
from struct import pack, unpack, unpack_from, calcsize
from volatility.plugins.linux.linux_yarascan import VmaYaraScanner

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False

LINUX_RAKOS_A_RULE = {
    'namespace1' : 'rule LinuxRakosA { \
                    strings: \
                       $ = "upgrade/vars.yaml" \
                       $ = "MUTTER" \
                       $ = "/tmp/.javaxxx" \
                       $ = "uckmydi" \
                    condition: 3 of them }'
}

LINUX_RAKOS_A_CONF = [['LinuxRakosA_config', '---\x0A\x0Aversion(.+?)skaro(.+?)\x0A\x0Asmtp(.+?)\x0A\x00\x00\x00\x00', 1],
['LinuxRakosA_ping', '\x7B\x22arch(.+?)stats(.+?)facts(.+?)load(.+?)version\x22\x3A(\d{3})\x7D', 0],
]

LINUX_RAKOS_A_FILTER = [['netstat', '127.0.0.1', '61314']
]


class ioc_linux_rakos_a(malfind.YaraScan):
    "Find indicators of compromise for: Linux/Rakos.A"

    @staticmethod
    def is_valid_profile(profile):
        return profile.metadata.get('os', 'Unknown').lower() == 'linux'

    def filter_tasks(self):
        tasks = pslist.linux_pslist(self._config).calculate()
        tasks_filt = []
        for task in tasks:
            for c_plug, c_param1, c_param2 in LINUX_RAKOS_A_FILTER: 
                if c_plug == 'netstat':
                    for ents in task.netstat():
                        if ents[0] == socket.AF_INET:
                            (_, proto, saddr, sport, daddr, dport, state) = ents[1]
                            if (str(saddr) == c_param1) and (str(sport) == c_param2):
                                tasks_filt.append(task)
                                print("Suspected PID: {0:8s} {1:<16}:{2:>5} {3:<16}:{4:>5} {5:<15s} {6:>17s}/{7:<5d}\n".format(proto, saddr, sport, daddr, dport, state, task.comm, task.pid))

        return tasks_filt
   
    def calculate(self):
    
        ## we need this module imported
        if not has_yara:
            debug.error("Please install Yara from https://plusvic.github.io/yara/")
            
        ## leveraged from the windows yarascan plugin
        rules = yara.compile(sources = LINUX_RAKOS_A_RULE)
            
        ## set the linux plugin address spaces 
        linux_common.set_plugin_members(self)
    
        tasks = self.filter_tasks()
        for task in tasks: 
            scanner = VmaYaraScanner(task = task, rules = rules)
            for hit, address in scanner.scan():
               yield (task, address, hit, scanner.address_space.zread(address - self._config.REVERSE, self._config.SIZE))
               break

    def render_text(self, outfd, data):

        banners = linux_banner.linux_banner(self._config).calculate()
        for banner in banners:
            outfd.write("Memory dump from:\n {0:s}\n\n".format(banner))
        cpus = linux_cpuinfo.linux_cpuinfo(self._config).calculate()
        for idx, vendor_id, model_id in cpus:
            outfd.write("Processor {0}: {1:s} {2:s}\n\n".format(idx, vendor_id, model_id))

        for task, address, hit, buf in data:
            if task:
                outfd.write("Task {0}/{1} confirmed for hitting the rule {2} at the address {3:#x}\n".format( task.comm, task.pid, hit.rule, address))
                for vma in task.get_proc_maps():
                    proc_addr_space = task.get_process_address_space()
                    datax = proc_addr_space.zread(vma.vm_start, vma.vm_end - vma.vm_start)
                    for c_name, c_pt, c_all in LINUX_RAKOS_A_CONF:
                        if c_all == 1:
                            prog = re.compile(c_pt, re.DOTALL)
                        else:
                            prog = re.compile(c_pt)
                        for m_conf in prog.finditer(datax):
                            buf = proc_addr_space.zread(vma.vm_start + m_conf.start() , m_conf.end() - m_conf.start())
                            #outfd.write("".join(["{0:#010x}  {1:<48}  {2}\n".format( address + o, h, ''.join(c)) for o, h, c in utils.Hexdump(buf)]))
                            
                            fname = "%s_%s_%u_0x%x.dat"%(c_name, task.comm, task.pid, vma.vm_start + m_conf.start() )
                            print "Found and writing to the file %s"%(fname)
                            with open(fname, 'wb') as f:
                                f.write(buf)
                            f.close()                