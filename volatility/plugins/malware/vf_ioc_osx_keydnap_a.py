# Detecting APT17 malware for Volatility
#
# How to use:
# 1. cd %Volatility%
# 2. mv _vf_iocs_osx_keydnap_a.py volatility/plugins/malware
#
#Command:
#python vol.py [ vf_iocs_osx_keydnap_a ] -f C:\results\_VB2016\_.vdi\vboxdump_MacYosemite_10_10_5_14F27_AMDx64_0_mal.vdi --profile=MacYosemite_10_10_5_14F27_AMDx64

import volatility.plugins.taskmods as taskmods
import volatility.win32.tasks as tasks
import volatility.utils as utils
import volatility.debug as debug
import volatility.plugins.malware.malfind as malfind
import volatility.plugins.malware as malware
import re
from struct import pack, unpack, unpack_from, calcsize

try:
    import yara
    has_yara = True
except ImportError:
    has_yara = False

osx_keydnap_a_sig = {
    'namespace1' : 'rule OSX_Keydnap_A { \
                    strings: \
                       $v1 = "icloudsyncd" \
                       $v2 = "bot_id="\
                       $v3 = "Passwords not saved"\
                       $v4 = "login.keychain"\
                    condition: $v1 and $v2 and $v3 and $v4 } '
}

class patternCheck():
    def __init__(self, malname, data):
        for c_name, c_pt in CONF_PATTERNS:
            if c_name in str(malname):
                self.m_conf = re.search(c_pt, data)
                break
            else:
                self.m_conf = None

        for s_name, s_pt in SIZE_PATTERNS:
            if s_name in str(malname):
                self.m_size = re.search(s_pt, data)
                break
            else:
                self.m_size = None

class vad_ck():
    def get_vad_end(self, task, address):
        for vad in task.VadRoot.traverse():
            if address == vad.Start:
                return vad.End+1

        return None

class vf_iocs_osx_keydnap_a(taskmods.DllList):
    "Detect IoCs of systems compromised with OSX/Keydnap.A malware"

    @staticmethod
    def is_valid_profile(profile):
        print "Profile: %s"%(profile.metadata.get('os', 'unknown'))
        print "Memory model: %s"%(profile.metadata.get('memory_model', '32bit'))
        return (profile.metadata.get('os', 'unknown') == 'mac'), profile.metadata.get('memory_model', '32bit')

    def get_vad_base(self, task, address):
        for vad in task.VadRoot.traverse():
            if address >= vad.Start and address < vad.End:
                return vad.Start

        return None

    def calculate(self):

        if not has_yara:
            debug.error("Yara must be installed for this plugin")

        addr_space = utils.load_as(self._config)

        os , memory_model = self.is_valid_profile(addr_space.profile)
        if not os:
            debug.error("This command does not support the selected profile.")

        rules = yara.compile(sources = osx_keydnap_a_sig)

        for task in self.filter_tasks(tasks.pslist(addr_space)):
            scanner = malfind.VadYaraScanner(task = task, rules = rules)

            for hit, address in scanner.scan():

                vad_base_addr = self.get_vad_base(task, address)

                yield task, vad_base_addr, hit, memory_model
                break

    def render_text(self, outfd, data):

        self.table_header(outfd, [("Name", "20"),
                                  ("PID", "8"),
                                  ("Data VA", "[addrpad]"),
                                  ("Malware Name", "13")])

        for task, start, malname, memory_model in data:
            self.table_row(outfd, task.ImageFileName, task.UniqueProcessId, start, malname)

